name: Reusable PageSpeed Performance Check

on:
  workflow_call:
    secrets:
      PAGESPEED_API_KEY: { required: true }

jobs:
  performance-check:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      pull-requests: write
      checks: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug repository info
        run: |
          echo "Repository URL: ${{ github.repository }}"
          echo "Repository owner: ${{ github.repository_owner }}"
          echo "Repository name: ${{ github.event.repository.name }}"
          echo "Pull request head: ${{ github.event.pull_request.head.repo.full_name }}"

      - name: Extract URLs from PR Description
        id: extract-urls
        uses: actions/github-script@v7
        with:
          script: |
            const prBody = context.payload.pull_request.body || '';

            // Multiple patterns to catch different formats
            const previewPatterns = [
              /(?:preview|staging|test|dev)[\s:*-]*\s*(https:\/\/[^\s\)\],]+)/i,
              /\*\*preview\*\*[\s:*-]*\s*(https:\/\/[^\s\)\],]+)/i,
              /<!--\s*preview:\s*(https:\/\/[^\s\)]+)\s*-->/i
            ];
            const livePatterns = [
              /(?:live|production|prod|main)[\s:*-]*\s*(https:\/\/[^\s\)\],]+)/i,
              /\*\*live\*\*[\s:*-]*\s*(https:\/\/[^\s\)\],]+)/i,
              /<!--\s*live:\s*(https:\/\/[^\s\)]+)\s*-->/i
            ];

            let previewUrl = null;
            let liveUrl = null;

            // Try each pattern
            for (const pattern of previewPatterns) {
              const match = prBody.match(pattern);
              if (match) {
                previewUrl = match[1].replace(/[,\.\)]+$/, ''); // Clean trailing punctuation
                break;
              }
            }

            for (const pattern of livePatterns) {
              const match = prBody.match(pattern);
              if (match) {
                liveUrl = match[1].replace(/[,\.\)]+$/, '');
                break;
              }
            }

            if (!previewUrl || !liveUrl) {
              const errorMsg = `
              ‚ùå Could not extract URLs from PR description.

              **Found:**
              - Preview URL: ${previewUrl || '‚ùå Not found'}
              - Live URL: ${liveUrl || '‚ùå Not found'}

              **Please format your PR description like this:**
              \`\`\`
              Preview: https://your-preview-url.myshopify.com
              Live: https://your-live-store.com
              \`\`\`

              Or use the PR template for automatic formatting.
              `;

              core.setFailed(errorMsg);

              // Post helpful comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: errorMsg
              });
              
              return;
            }
            
            core.setOutput('preview_url', previewUrl);
            core.setOutput('live_url', liveUrl);
            
            console.log(`‚úÖ Preview URL: ${previewUrl}`);
            console.log(`‚úÖ Live URL: ${liveUrl}`);

      - name: Run PageSpeed Insights
        id: pagespeed
        env:
          PREVIEW_URL: ${{ steps.extract-urls.outputs.preview_url }}
          LIVE_URL: ${{ steps.extract-urls.outputs.live_url }}
          PSI_API_KEY: ${{ secrets.PAGESPEED_API_KEY }}
        run: |
          node << 'EOF'
          const https = require('https');
          const fs = require('fs');

          const API_KEY = process.env.PSI_API_KEY || '';
          const PREVIEW_URL = process.env.PREVIEW_URL;
          const LIVE_URL = process.env.LIVE_URL;

          function runPageSpeed(url, strategy = 'mobile') {
            return new Promise((resolve, reject) => {
              const apiUrl = `https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${encodeURIComponent(url)}&strategy=${strategy}&category=performance${API_KEY ? '&key=' + API_KEY : ''}`;

              const request = https.get(apiUrl, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    try {
                      resolve(JSON.parse(data));
                    } catch (parseError) {
                      reject(new Error(`Failed to parse JSON: ${parseError.message}`));
                    }
                  } else {
                    reject(new Error(`API returned ${res.statusCode}: ${data}`));
                  }
                });
              }).on('error', reject);

              // Increased timeout (120 seconds)
              request.setTimeout(120000, () => {
                request.destroy();
                reject(new Error('Request timeout after 120 seconds'));
              });
            });
          }

          async function runPageSpeedWithRetry(url, strategy, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
              try {
                console.log(`Attempt ${i + 1}/${maxRetries} for ${strategy} - ${url}`);
                return await runPageSpeed(url, strategy);
              } catch (error) {
                console.error(`Error on attempt ${i + 1}: ${error.message}`);
                if (i === maxRetries - 1) {
                  throw error;
                }
                // Exponential backoff
                const delay = 5000 * (i + 1);
                console.log(`Retrying in ${delay / 1000} seconds...`);
                await new Promise(resolve => setTimeout(resolve, delay));
              }
            }
          }

          async function analyzePerformance() {
            try {
              const NUM_RUNS = 1; // single run per config (with retries)

              // Helper function to run multiple times and calculate average
              async function runMultipleTimesAndAverage(url, strategy, label) {
                console.log(`\nüìä Running ${NUM_RUNS} test(s) for ${label} (${strategy})...`);
                const runs = [];
                
                for (let i = 0; i < NUM_RUNS; i++) {
                  console.log(`  Run ${i + 1}/${NUM_RUNS}...`);
                  try {
                    const data = await runPageSpeedWithRetry(url, strategy);
                    runs.push(data);
                  } catch (error) {
                    console.error(`  ‚ùå Run ${i + 1} failed: ${error.message}`);
                    // If no successful runs at all, mark as no data for this config
                    if (runs.length === 0) {
                      console.error(`All runs failed for ${label} (${strategy}): ${error.message}`);
                      return {
                        score: 0,
                        fcp: 0,
                        lcp: 0,
                        tbt: 0,
                        cls: 0,
                        si: 0,
                        runs: 0,
                        error: `All runs failed for ${label} (${strategy})`
                      };
                    }
                    // Otherwise just skip this run and continue (we'll average what we have)
                  }

                  // Delay between runs (kept for NUM_RUNS > 1, harmless here)
                  if (i < NUM_RUNS - 1) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                  }
                }

                const effectiveRuns = runs.length;
                console.log(`  ‚úÖ Completed ${effectiveRuns} successful run(s) for ${label} (${strategy})`);

                const avg = (getter, scale = 1) =>
                  runs.reduce((sum, r) => sum + (getter(r) || 0), 0) / effectiveRuns / scale;

                const avgScore = runs.reduce(
                  (sum, r) => sum + (r.lighthouseResult?.categories?.performance?.score || 0),
                  0
                ) / effectiveRuns * 100;

                const avgFcp = avg(
                  r => r.lighthouseResult?.audits?.['first-contentful-paint']?.numericValue,
                  1000
                );
                const avgLcp = avg(
                  r => r.lighthouseResult?.audits?.['largest-contentful-paint']?.numericValue,
                  1000
                );
                const avgTbt = avg(
                  r => r.lighthouseResult?.audits?.['total-blocking-time']?.numericValue
                );
                const avgCls = avg(
                  r => r.lighthouseResult?.audits?.['cumulative-layout-shift']?.numericValue
                );
                const avgSi = avg(
                  r => r.lighthouseResult?.audits?.['speed-index']?.numericValue,
                  1000
                );

                console.log(`  ‚úÖ Average Score: ${avgScore.toFixed(1)} (from ${effectiveRuns} run(s))`);

                return {
                  score: avgScore,
                  fcp: avgFcp,
                  lcp: avgLcp,
                  tbt: avgTbt,
                  cls: avgCls,
                  si: avgSi,
                  runs: effectiveRuns
                };
              }

              console.log('üöÄ Starting performance analysis with 1 run per test (with retries, sequential)...\n');

              // Run configs SEQUENTIALLY to reduce API pressure / timeouts
              const liveMobileAvg    = await runMultipleTimesAndAverage(LIVE_URL,    'mobile',  'Live URL');
              await new Promise(r => setTimeout(r, 2000));

              const liveDesktopAvg   = await runMultipleTimesAndAverage(LIVE_URL,    'desktop', 'Live URL');
              await new Promise(r => setTimeout(r, 2000));

              const previewMobileAvg = await runMultipleTimesAndAverage(PREVIEW_URL, 'mobile',  'Preview URL');
              await new Promise(r => setTimeout(r, 2000));

              const previewDesktopAvg = await runMultipleTimesAndAverage(PREVIEW_URL, 'desktop', 'Preview URL');

              const results = {
                mobile: {
                  live: liveMobileAvg,
                  preview: previewMobileAvg
                },
                desktop: {
                  live: liveDesktopAvg,
                  preview: previewDesktopAvg
                }
              };

              // Track data issues (timeouts / no data)
              const dataIssues = [];
              if (liveMobileAvg.runs === 0)   dataIssues.push('No data for Live Mobile (PageSpeed timeouts)');
              if (liveDesktopAvg.runs === 0)  dataIssues.push('No data for Live Desktop (PageSpeed timeouts)');
              if (previewMobileAvg.runs === 0) dataIssues.push('No data for Preview Mobile (PageSpeed timeouts)');
              if (previewDesktopAvg.runs === 0) dataIssues.push('No data for Preview Desktop (PageSpeed timeouts)');
              results.dataIssues = dataIssues;

              // Calculate deltas for both mobile and desktop
              results.mobile.delta = {
                score: previewMobileAvg.score - liveMobileAvg.score,
                fcp:   previewMobileAvg.fcp   - liveMobileAvg.fcp,
                lcp:   previewMobileAvg.lcp   - liveMobileAvg.lcp,
                tbt:   previewMobileAvg.tbt   - liveMobileAvg.tbt,
                cls:   previewMobileAvg.cls   - liveMobileAvg.cls,
                si:    previewMobileAvg.si    - liveMobileAvg.si
              };

              results.desktop.delta = {
                score: previewDesktopAvg.score - liveDesktopAvg.score,
                fcp:   previewDesktopAvg.fcp   - liveDesktopAvg.fcp,
                lcp:   previewDesktopAvg.lcp   - liveDesktopAvg.lcp,
                tbt:   previewDesktopAvg.tbt   - liveDesktopAvg.tbt,
                cls:   previewDesktopAvg.cls   - liveDesktopAvg.cls,
                si:    previewDesktopAvg.si    - liveDesktopAvg.si
              };

              // Determine status for both mobile and desktop
              let mobileStatus = 'pass';
              let desktopStatus = 'pass';
              let mobileFailureReasons = [];
              let desktopFailureReasons = [];

              // Check mobile performance
              if (results.mobile.delta.score < -20) {
                mobileStatus = 'fail';
                mobileFailureReasons.push(`Mobile performance score dropped by ${Math.abs(results.mobile.delta.score).toFixed(1)} points`);
              }
              if (results.mobile.delta.lcp > 2) {
                mobileStatus = 'fail';
                mobileFailureReasons.push(`Mobile LCP increased by ${results.mobile.delta.lcp.toFixed(2)}s`);
              }
              if (results.mobile.delta.cls > 0.1) {
                mobileStatus = mobileStatus === 'fail' ? 'fail' : 'warning';
                mobileFailureReasons.push(`Mobile CLS increased by ${results.mobile.delta.cls.toFixed(3)}`);
              }
              if (results.mobile.delta.fcp > 1) {
                mobileStatus = mobileStatus === 'fail' ? 'fail' : 'warning';
                mobileFailureReasons.push(`Mobile FCP increased by ${results.mobile.delta.fcp.toFixed(2)}s`);
              }

              // Check desktop performance
              if (results.desktop.delta.score < -20) {
                desktopStatus = 'fail';
                desktopFailureReasons.push(`Desktop performance score dropped by ${Math.abs(results.desktop.delta.score).toFixed(1)} points`);
              }
              if (results.desktop.delta.lcp > 2) {
                desktopStatus = 'fail';
                desktopFailureReasons.push(`Desktop LCP increased by ${results.desktop.delta.lcp.toFixed(2)}s`);
              }
              if (results.desktop.delta.cls > 0.1) {
                desktopStatus = desktopStatus === 'fail' ? 'fail' : 'warning';
                desktopFailureReasons.push(`Desktop CLS increased by ${results.desktop.delta.cls.toFixed(3)}`);
              }
              if (results.desktop.delta.fcp > 1) {
                desktopStatus = desktopStatus === 'fail' ? 'fail' : 'warning';
                desktopFailureReasons.push(`Desktop FCP increased by ${results.desktop.delta.fcp.toFixed(2)}s`);
              }

              // Base overall status from performance deltas
              let overallStatus =
                mobileStatus === 'fail' || desktopStatus === 'fail'
                  ? 'fail'
                  : mobileStatus === 'warning' || desktopStatus === 'warning'
                    ? 'warning'
                    : 'pass';

              // If any configs had no data but we otherwise passed, downgrade to warning
              if (results.dataIssues.length > 0 && overallStatus === 'pass') {
                overallStatus = 'warning';
              }

              results.mobile.status = mobileStatus;
              results.mobile.failureReasons = mobileFailureReasons;
              results.desktop.status = desktopStatus;
              results.desktop.failureReasons = desktopFailureReasons;
              results.status = overallStatus;

              fs.writeFileSync('results.json', JSON.stringify(results, null, 2));

              console.log('\n‚úÖ Analysis complete! (1 run per test with retries; timeouts become warnings)');
              console.log('RESULTS:', JSON.stringify(results, null, 2));
            } catch (error) {
              console.error('Fatal error during analysis:', error);
              throw error;
            }
          }

          analyzePerformance().catch(err => {
            console.error('Error:', err.message);
            process.exit(1);
          });
          EOF

      - name: Post Results Comment
        uses: actions/github-script@v7
        env:
          LIVE_URL: ${{ steps.extract-urls.outputs.live_url }}
          PREVIEW_URL: ${{ steps.extract-urls.outputs.preview_url }}
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('results.json', 'utf8'));

            const statusEmoji = {
              pass: '‚úÖ',
              warning: '‚ö†Ô∏è',
              fail: '‚ùå'
            };

            const formatDelta = (value, unit = '', inverse = false) => {
              const isPositive = inverse ? value < 0 : value > 0;
              const emoji = isPositive ? 'üìà' : 'üìâ';
              const sign = value > 0 ? '+' : '';
              return `${emoji} ${sign}${value.toFixed(2)}${unit}`;
            };

            const dataIssuesText = (results.dataIssues && results.dataIssues.length)
              ? `\n\n> ‚ö†Ô∏è **Note:** Some PageSpeed requests timed out:\n${results.dataIssues.map(i => `> - ${i}`).join('\n')}`
              : '';

            const comment = `## ${statusEmoji[results.status]} PageSpeed Performance Report

            > üìä **Note:** Metrics are based on a single run per test with retries to avoid API timeouts.${dataIssuesText}

            ### üì± Mobile Performance
            | Environment | Score | Change |
            |-------------|-------|--------|
            | **Live** | ${results.mobile.live.score.toFixed(1)} | - |
            | **Preview** | ${results.mobile.preview.score.toFixed(1)} | ${formatDelta(results.mobile.delta.score, '', true)} |

            #### Mobile Core Web Vitals
            | Metric | Live | Preview | Change |
            |--------|------|---------|--------|
            | **LCP** (Largest Contentful Paint) | ${results.mobile.live.lcp.toFixed(2)}s | ${results.mobile.preview.lcp.toFixed(2)}s | ${formatDelta(results.mobile.delta.lcp, 's')} |
            | **FCP** (First Contentful Paint) | ${results.mobile.live.fcp.toFixed(2)}s | ${results.mobile.preview.fcp.toFixed(2)}s | ${formatDelta(results.mobile.delta.fcp, 's')} |
            | **CLS** (Cumulative Layout Shift) | ${results.mobile.live.cls.toFixed(3)} | ${results.mobile.preview.cls.toFixed(3)} | ${formatDelta(results.mobile.delta.cls)} |
            | **TBT** (Total Blocking Time) | ${results.mobile.live.tbt.toFixed(0)}ms | ${results.mobile.preview.tbt.toFixed(0)}ms | ${formatDelta(results.mobile.delta.tbt, 'ms')} |
            | **SI** (Speed Index) | ${results.mobile.live.si.toFixed(2)}s | ${results.mobile.preview.si.toFixed(2)}s | ${formatDelta(results.mobile.delta.si, 's')} |

            ### üñ•Ô∏è Desktop Performance
            | Environment | Score | Change |
            |-------------|-------|--------|
            | **Live** | ${results.desktop.live.score.toFixed(1)} | - |
            | **Preview** | ${results.desktop.preview.score.toFixed(1)} | ${formatDelta(results.desktop.delta.score, '', true)} |

            #### Desktop Core Web Vitals
            | Metric | Live | Preview | Change |
            |--------|------|---------|--------|
            | **LCP** (Largest Contentful Paint) | ${results.desktop.live.lcp.toFixed(2)}s | ${results.desktop.preview.lcp.toFixed(2)}s | ${formatDelta(results.desktop.delta.lcp, 's')} |
            | **FCP** (First Contentful Paint) | ${results.desktop.live.fcp.toFixed(2)}s | ${results.desktop.preview.fcp.toFixed(2)}s | ${formatDelta(results.desktop.delta.fcp, 's')} |
            | **CLS** (Cumulative Layout Shift) | ${results.desktop.live.cls.toFixed(3)} | ${results.desktop.preview.cls.toFixed(3)} | ${formatDelta(results.desktop.delta.cls)} |
            | **TBT** (Total Blocking Time) | ${results.desktop.live.tbt.toFixed(0)}ms | ${results.desktop.preview.tbt.toFixed(0)}ms | ${formatDelta(results.desktop.delta.tbt, 'ms')} |
            | **SI** (Speed Index) | ${results.desktop.live.si.toFixed(2)}s | ${results.desktop.preview.si.toFixed(2)}s | ${formatDelta(results.desktop.delta.si, 's')} |

            ${results.mobile.failureReasons.length > 0 || results.desktop.failureReasons.length > 0 ? `### ‚ö†Ô∏è Issues Detected\n${[...results.mobile.failureReasons, ...results.desktop.failureReasons].map(r => `- ${r}`).join('\n')}` : ''}

            ---

            ${results.status === 'pass' ? '‚úÖ **Performance check passed!** No significant regressions detected on either mobile or desktop.' : ''}
            ${results.status === 'warning' ? '‚ö†Ô∏è **Warning:** Performance data is incomplete or minor regressions detected. Please review the details above.' : ''}
            ${results.status === 'fail' ? '‚ùå **Performance check failed!** Significant regression detected. Please optimize before merging.' : ''}

            <details>
            <summary>üìä View detailed analysis</summary>

            - **Live URL:** ${process.env.LIVE_URL}
            - **Preview URL:** ${process.env.PREVIEW_URL}
            - **Test Date:** ${new Date().toISOString()}
            - **Strategies:** Mobile & Desktop
            - **Runs per test:** 1 (with retries)

            </details>
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: Set Check Status
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('results.json', 'utf8'));

            if (results.status === 'fail') {
              core.setFailed('‚ùå Performance regression detected! Check the PR comment for details.');
            } else if (results.status === 'warning') {
              console.log('‚ö†Ô∏è Performance warnings or incomplete data detected. Review recommended.');
            } else {
              console.log('‚úÖ Performance check passed!');
            }